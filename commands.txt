data_cleaning
data
Data I/O
Read and write .csv
import delimited using "https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv", clear \nexport delimited using "flightdata.csv", replace
dat = fread('https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv')\nfwrite(dat, 'flightdata.csv')

data_cleaning
data
Data I/O
Read and write .dta
* .dta is Stata's native (proprietary) filetype \nuse "filename.dta", clear \n\n\nsave "filename.dta", replace
# These commands require the `haven` package \ndat = haven::read_dta('filename.dta') \nsetDT(dat) # Or: dat = as.data.table(dat) \n \nhaven::write_dta(dat, 'filename.dta')

data_cleaning
sort
Sort & rename
Sort rows
sort air_time \nsort air_time dest \nsort -air_time\n\n
setorder(dat, air_time) \nsetorder(dat, air_time, dest) \nsetorder(dat, -air_time)

data_cleaning
sort
Sort & rename
Sort columns
order month day
setcolorder(dat, c('month','day'))

data_cleaning
sort
Sort & rename
Rename columns
* rename (old) (new) \n\nrename arr_delay arrival_delay \nrename (carrier origin) (carrier_code origin_code) \n\n\nrename arr_* arrival_*
# setnames(dat, old = ..., new = ...) \n\nsetnames(dat, 'arr_delay', 'arrival_delay') \nsetnames(dat, c('carrier','origin'), c('carrier_code','origin_code')) \n\n# Easiest just to reassign names using gsub \nnames(dat) = gsub('arr_', 'arrival_', names(dat))

data_cleaning
subset
Subset
Subset rows
keep in 1/200 \nkeep if day > 5 & day < 10\nkeep if inrange(day,5,10)\nkeep if origin == "LGA"\nkeep if regex(origin,"LGA") \nkeep if inlist(month,3,4,11,12) \nkeep if inlist(origin,"JFK","LGA") \ndrop if month == 1
dat1 = dat[1:200] \ndat1 = dat[day > 5 & day < 10] \ndat1 = dat[between(day,5,10)] # Or: dat1 = dat[day %in% 5:10] \ndat1 = dat[origin=='LGA']\ndat1 = dat[origin %like% 'LGA'] \ndat1 = dat[month %in% c(3,4,11,12)] \ndat1 = dat[origin %chin% c("JFK","LGA")] # %chin% is a faster %in% for (ch)aracter strings \ndat1 = dat[month!=1]

data_cleaning
subset
Subset
Subset columns
keep month day carrier \n\n\n\nkeep year-arr_delay\nkeep *_delay \n\nds, has(type int) \nkeep `r(varlist)'\n\ndrop origin dest \n\n\nds, has(type string) \ndrop `r(varlist)'
dat1 = dat[, .(month, day, carrier)] \ndat1 = dat[, list(month, day, carrier)] # same as above \ndat1 = dat[, c('month', 'day', 'carrier')] # ditto \n\ndat1 = dat[, year:arr_delay] \ndat1 = dat[, .SD, .SDcols=patterns('*_delay')] \n\n# Matches the two lines on the left: \ndat1 = dat[, .SD, .SDcols=is.integer] \n\ndat1 = dat[, -c('origin', 'dest')]\ndat1 = dat[, c('origin', 'dest') := NULL] # same effect as above, but in-place \n\n# Matches the two lines on the left:\ndat1 = dat[, .SD, .SDcols=!is.character]

data_cleaning
subset
Subset
Subset rows and columns
keep if origin == "LGA"\nkeep month day carrier
# Matches the two lines on the left:\ndat1 = dat[origin=="LGA", .(month, day, carrier)]

data_cleaning
subset
Subset
Drop duplicates
duplicates drop\nduplicates drop month day carrier, force\n
dat1 = unique(dat) \ndat1 = unique(dat, by = c('month', 'day', 'carrier'))

data_cleaning
subset
Subset
Drop missing
keep if !missing(dest)\n* Requires: ssc inst missings\nmissings dropvars, force \nmissings air_time dest, force \n
dat1 = dat[!is.na(dest)]\n\ndat1 = na.omit(dat) \ndat1 = na.omit(dat, c('air_time', 'dest')) \ndat1 = dat[!is.na(air_time) & !is.na(dest)] # Same as above

data_cleaning
modify
Modify
Create new variables
gen dist_sq = distance^2 \ngen tot_delay = dep_delay + arr_delay \ngen first_letter = substr(origin, 1,1) \ngen flight_path = origin + '_' + dest \n\n* These next operations don't have a great Stata \n* equivalent, although you could implement a loop
dat[, dist_sq := distance^2] \ndat[, tot_delay := dep_delay + arr_delay] \ndat[, first_letter := substr(origin,1,1)] \ndat[, flight_path := paste(origin, dest, sep='_')] \n\n# Multiple variables can be created at the same time \ndat[, c('dist_sq', 'dist_cu') := .(distance^2, distance^3)] \ndat[, ':=' (dist_sq=distance^2, dist_cu=distance^3)] # "functional" equivalent \n\n# We can also chain back-to-back dat[...][...] \n# (this holds for any data.table operation) \ndat[, dist_sq := distance^2][, dist_cu := distance*dist_sq)]

data_cleaning
modify
Modify
Create new variables within groups
bysort origin: egen mean_dep_delay = mean(dep_delay) \nbysort origin dest: egen mean_dep_delay2 = mean(dep_delay) \n\n* Multiple grouped variables (manual demean example) \nforeach x of varlist dep_delay arr_delay air_time {\n    egen mean_`x'=mean(`x'), by(origin) \n    gen `x'_dm = `x` - mean_`x' \n    drop mean* \n}\n\n* Some short-cut symbols \nbysort carrier: g rows_per_carrier = _N \nbysort carrier: g index_within_carrier = _n \negen origin_index = group(origin)\n\n* Refer to other rows (uses generic data set)\nsort group time\nby group: generate growth = X/X[_n-1]\nby group: generate growth_since_first = X/X[1]
dat[, mean_dep_delay := mean(dep_delay), by=origin] \ndat[, mean_dep_delay2 := mean(dep_delay), by=.(origin, dest)] \n\n# Multiple grouped variables (manual demean example) \ndmcols = c('dep_delay', 'arr_delay', 'air_time') \ndat[, paste0(dmcols, '_dm') := lapply(.SD, \(x) x-mean(x)),  # before R 4.1 you'll need function(x) instead of the \(x) shorthand\n  .SDcols = dmcols,\n  by=origin] \n\n\n# Some short-cut symbols \ndat[, rows_per_carrier := .N, by = carrier] \ndat[, index_within_carrier := .I, by = carrier] \ndat[, origin_index := .GRP, by = origin]\n\n# Refer to other rows (uses generic data set)\nsetorder(dat, group, time)\ndat[, growth := X/shift(X, 1), by = group]\ndat[, growth_since_first := X/first(X), by = group]

data_cleaning
modify
Modify
Modify existing variables
replace tot_delay = dep_delay + arr_delay \n\n* Conditional modification \nreplace distance = distance + 1 if month==9\nreplace distance = 0 in 1
dat[, tot_delay := dep_delay + arr_delay] \n\n# Conditional modification \ndat[month==9, distance := distance + 1]\ndat[1, distance := 0]\n\n# Modify multiple variables at once with the same function\ncols = c('origin','dest')\ndat[, (cols) := lapply(.SD, \(x) paste(x,'Airport')), .SDcols = cols] # before R 4.1 you need function(x) instead of the \(x) shorthand

data_cleaning
modify
Modify
Using Booleans & control-flow
generate long_flight = air_time>500 & !missing(air_time) \n\ngenerate flight_length = "Long" if air_time>500 & !missing(air_time)\nreplace flight_length = "Short" if missing(flight_length) & !missing(air_time) \n\n\ngenerate flight_length2 = "Long" if !missing(air_time) \nreplace flight_length2 = "Med" if air_time<=500  \nreplace flight_length2 = "Short" if air_time<=120
dat[, long_flight := air_time>500] \n\ndat[, flight_length := fifelse(air_time>500, 'Long', 'Short')] \n# fifelse is like base-R ifelse, but (f)aster! \n\n# for nested ifelse, easier to use fcase \ndat[, flight_length2 := fcase(air_time<=120, 'Short', \n                            air_time<=500, 'Med', \n                            default = 'Long')]

data_cleaning
modify
Modify
Row-wise calculations
* Pre-packaged row calculations: \negen tot_delay = rowtotal(*_delay)\negen any_delay = rowfirst(*_delay)\n\n* Custom row calculations:\n* ?
# Pre-packaged row calculations: \ndat[, tot_delay := rowSums(.SD), .SDcols = patterns('*_delay')]\ndat[, any_delay := fcoalesce(.SD), .SDcols = patterns('*_delay')] \n\n# Custom row calculations: \ndat[, new_var := mapply(custom_func, var1, var2)] \ndat[, new_var := custom_func(var1, var2)), by=1:nrow(dat)] # Another option\n\n

data_cleaning
modify
Modify
Fill in Time Series/Panel Data
* Carry forward the last-known observation\nsort id time\nby id: replace x = x[_n-1] if missing(x)\n* Carry back the next-known observation\ngsort id -time\nby id: replace x = x[_n-1] if missing(x)
# Carry forward the last-known observation\nsetorder(dat, id, time)\ndat[, x := nafill(x, type = 'locf'), by = id]\n# Carry back the next-known observation\ndat[, x := nafill(x, type = 'nocb'), by = id]

data_cleaning
collapse
Collapse
Collapse by group
collapse (mean) arr_delay, by(carrier) \ncollapse (mean) arr_delay, by(carrier month) \ncollapse (mean) mean_adel = arr_delay, by(carrier) \n\ncollapse (min) min_d = distance (max) max_d = distance, by(origin) \n\ncollapse (mean) *_delay, by(origin) \ncollapse (mean) dep_delay arr_delay air_time distance, by(origin) \n\n\negen unique_dest = tag(dest origin) \ncollapse (sum) unique_dest, by(origin)
dat1 = dat[, .(arr_delay = mean(arr_delay)), by=carrier] \ndat1 = dat[, .(arr_delay = mean(arr_delay)), by=.(carrier, month)] \ndat1 = dat[, .(mean_adel = mean(arr_delay)), by=carrier] \n\ndat1 = dat[, .(min_d = min(distance), max_d = max(distance)), by=origin] \n\ndat1 = dat[, lapply(.SD, mean), .SDcols=patterns('_delay'), by=origin] \ndat1 = dat[, lapply(.SD, mean), .SDcols=c('dep_delay','arr_delay','air_time','distance'), by=origin] \ndat1 = dat[, lapply(.SD, mean), .SDcols = c(4,5,9,10), by=origin] # same as above \n\n# Matches the final two lines on the left: \ndat1 = dat[, .(unique_dest = uniqueN(dest)), by = origin]

data_cleaning
collapse
Collapse
Count rows
count\ncount if month==10
dat[, .N] # Or: nrow(dat) \ndat[month==10, .N] # Or: nrow(dat[month==10])

data_cleaning
reshape
Reshape
Reshape long
* Prepare to reshape long (this dataset only):\ngenerate id = _n \nrename (dep_delay arr_delay) (delay_dep delay_arr)\n\nreshape long delay_, i(id) j(delay_type) s
# Prepare to reshape long (this dataset only):\ndat[, id := .I] \n\ndat1 = melt(dat, measure.vars = c('arr_delay','dep_delay'))\n# note id.vars would normally be specified too, but here we're treating each row as its own ID

data_cleaning
reshape
Reshape
Reshape wide
* This starts with the reshaped-long data from above\nreshape wide delay_, (id) j(delay_type) s
# This starts with the reshaped-long data from above\ndat2 = dcast(dat1, id ~ variable)\n# (this drops all variables except id & *_delay, \n# but we could preserve them with id+origin+dest+etc. instead of just id)

data_cleaning
merge
Merge
Import secondary (airport) dataset
import delimited using "https://vincentarelbundock.github.io/Rdatasets/csv/nycflights13/airports.csv", clear\nsave dat2.dta, replace\nimport delimited using "https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv", clear
dat2 = fread("https://vincentarelbundock.github.io/Rdatasets/csv/nycflights13/airports.csv")

data_cleaning
merge
Merge
Various Merges
rename dest faa\n* Only keep matches (inner join)\nmerge m:1 faa using dat2.dta, keep(3) nogen\n* Keep all observations (full join)\nmerge m:1 faa using dat2.dta, nogen\n* Keep matches and "master" non-matches (left join)\nmerge m:1 faa using dat2.dta, keep(1 3) nogen\n* Keep matches and "using" non-matches (right join)\nmerge m:1 faa using dat2.dta, keep(2 3) nogen\n\nmerge m:1 faa using dat2.dta, keepusing(lat lon)\n\n\n\n\n\n\n\n\n\n\n\n\n* Keep only non-matches (anti-join)\nmerge m:1 faa using dat2.dta, keep(1 2) nogen
setnames(dat, 'dest', 'faa')\n# Only keep matches (inner join)\ndat_merged = merge(dat, dat2, by='dest')\n# Keep all observations (full join)\ndat_merged = merge(dat, dat2, by='dest', all = TRUE)\n# Keep matches and "master" non-matches (left join)\ndat_merged = merge(dat, dat2, by='dest', all.x = TRUE)\n# Keep matches and "using" non-matches (right join)\ndat_merged = merge(dat, dat2, by='dest', all.y = TRUE)\n\ndat_merged = merge(dat, dat2[, .(dest, lat, lon)], by='dest', all = TRUE)\n\n# Alternate merging approaches\n# Skip the setnames() and just merge with different variable names\ndat_merged = merge(dat, dat2, by.x='dest', by.y='faa') \n\n# If using keys, don't need 'by'/'on' (and faster) \nsetkey(dat, dest); setkey(dat2, dest) \ndat_merged = merge(dat, dat2)\n\n# Alternate, more data-tably syntax\n# That is also faster for some applications\ndat_merged = dat[dat2, on='dest']\n# Keep only non-matches (anti-join)\ndat_merged = dat[!dat2, on='dest']


regression
formula
Formula Creation
Fixed Effects
reghdfe y x, absorb(fe)
feols(y ~ x | fe, dat)

regression
formula
Formula Creation
Categorical Variables
reghdfe y x i.cat
feols(y ~ x + i(cat), dat)

regression
formula
Formula Creation
With Baseline
reghdfe y x ib1.cat
feols(y ~ x + i(cat, ref = 1), dat)

regression
formula
Formula Creation
Interact Categoricals
reghdfe y x i.cat#i.cat2
feols(y ~ x + i(cat, i.cat2), dat)

regression
formula
Formula Creation
Categorical and Continuous
reghdfe y x c.cont#i.cat
feols(y ~ x + i(cat, cont), dat)

regression
formula
Formula Creation
Macros
local vars varlist \n reghdfe y x `vars'
vars = c(...) \n feols(y ~ x + .[vars], dat)

regression
formula
Formula Creation
Wildcard
reghdfe y x age_*
feols(y ~ x + ..('age_'), dat)

regression
formula
Formula Creation
Variables v1 ... v4
reghdfe y x v1-v4
feols(y ~ x + v.[1:4], dat)

regression
formula
Formula Creation
Regex
 
feols(y ~ x + ..('regex_exp'), dat)

regression
std_errors
Standard Errors
HC
reghdfe y x, vce(hc1)
feols(y ~ x, dat, vcov = 'hc1')

regression
std_errors
Standard Errors
HAC
xtset id period\nivreghdfe y x, bw(auto) robust
feols(y ~ x, dat, vcov = NW() ~ id + period)\nfeols(y ~ x, dat, vcov = 'NW') # if panel id is already set (see below)

regression
std_errors
Standard Errors
Cluster
reghdfe y x, cluster(clust)
feols(y ~ x, dat, vcov = ~clust)

regression
std_errors
Standard Errors
Two-way
reghdfe y x, cluster(clust1 clust2)
feols(y ~ x, dat, vcov = ~clust1 + clust2)

regression
std_errors
Standard Errors
Conley Standard Errors
 
feols(y ~ x, dat, vcov = conley('lat', 'lon', 50))

regression
post
Postestimation

regression Table
reghdfe ... \n eststore est1 \n estout ...
est1 = feols(...) \n etable(est1)

regression
post
Postestimation
Coefficient Plot
reghdfe ... \n eststore est1 \n estout ...
est1 = feols(...) \n coefplot(est1)

regression
panel
Panel Data
Lag Variables
xtset unit time \n reg y x l1.x l2.x
panel(dat, ~unit + time) \n feols(y ~ x + l(x, 1:2), dat)

regression
panel
Panel Data
Lead Variables
xtset unit time \n reg y x f1.x f2.x
panel(dat, ~unit + time) \n feols(y ~ x + l(x, -2:-1), dat)

regression
panel
Panel Data
First Difference
xtset unit time \n reg y x D.x
panel(dat, ~unit + time) \n feols(y ~ x + d(x), dat)

regression
iv
Instrumental Variables
Instrumental Variables
ivreghdfe 2sls y x (x1 = z1)
feols(y ~ x | x1 ~ z1, dat)

regression
iv
Instrumental Variables
with Fixed Effects
ivreghdfe 2sls y x (x1 = z1), absorb(fe1)
feols(y ~ x | fe1 | x1 ~ z1, dat)
